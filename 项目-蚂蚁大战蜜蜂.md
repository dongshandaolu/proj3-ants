# 项目 3 | CS 61A 秋季 2021

**项目 3：蚂蚁大战蜜蜂**

## 引言

> **重要提交说明**：为了获得满分，
>
> *   在 **10月15日（星期五）** 前提交完成第一阶段的内容（占1分）。
> *   在 **10月19日（星期二）** 前提交完成第二和第三阶段的内容（占1分）。
> *   在 **10月22日（星期五）** 前提交完成所有阶段的内容。
>
> 请尝试按顺序解决问题，因为一些后续问题在实现上（以及因此在运行 `ok` 测试时）会依赖于先前的问题。
>
> 整个项目可以与一位搭档共同完成。
>
> 您可以通过在 **10月21日（星期四）** 前提交整个项目来获得1个额外的奖励积分。

在这个项目中，您将创建一个名为“蚂蚁大战蜜蜂”的[塔防](https://secure.wikimedia.org/wikipedia/en/wiki/Tower_defense)游戏。作为蚁后，您将用您能召集到的最勇敢的蚂蚁来填充您的蚁巢。您的蚂蚁必须保护蚁后免受入侵您领土的邪恶蜜蜂的侵害。通过向蜜蜂投掷树叶来激怒它们，它们就会被消灭。如果未能充分骚扰这些空中入侵者，您的蚁后将屈服于蜜蜂的愤怒。这款游戏的灵感来源于 PopCap Games 的[植物大战僵尸](https://www.ea.com/studios/popcap/plants-vs-zombies)。

本项目使用面向对象编程范式，重点关注 Composing Programs [第 2.5 章](http://composingprograms.com/pages/25-object-oriented-programming.html) 的内容。该项目还涉及理解、扩展和测试一个大型程序。

> 过去，当学生们试图在没有彻底阅读问题描述的情况下实现功能时，他们经常会遇到问题。 😱
> **在开始编码之前，请仔细阅读每个描述。**

## 下载起始文件

[ants.zip](ants.zip) 压缩包包含多个文件，但您所有的更改都将在 `ants.py` 中进行。

*   `ants.py`: 蚂蚁大战蜜蜂的游戏逻辑
*   `ants_gui.py`: 蚂蚁大战蜜蜂的原始 GUI
*   `gui.py:` 蚂蚁大战蜜蜂的新 GUI。
*   `graphics.py`: 用于显示简单二维动画的实用工具
*   `utils.py`: 一些用于辅助游戏界面的函数
*   `ucb.py`: CS 61A 的实用函数
*   `state.py`: 用于 gui.py 的游戏状态抽象
*   `assets`: `gui.py` 使用的图像和文件目录
*   `img`: `ants_gui.py` 使用的图像目录
*   `ok`: 自动评分器
*   `proj3.ok`: `ok` 配置文件
*   `tests`: `ok` 使用的测试目录

## 项目安排

> 项目总共25分。
> 其中21分用于考察正确性，
> 2分用于考察代码风格，
> 1分用于在第一个检查点日期前提交第一阶段，
> 1分用于在第二个检查点日期前提交第二和第三阶段。

此外，还有一些额外的加分机会。
您可以通过在 **10月21日（星期四）** 前提交整个项目来获得1个额外的加分，
以及通过提交附加题来获得2个额外的加分。

> **重要提示：**
> 为了获得蚂蚁项目的所有额外加分，
> 您必须在早期提交截止日期前提交整个项目的实现，
> 包括附加题。

您需要提交以下文件：

*   `ants.py`

您不需要修改或提交任何其他文件来完成此项目。要提交项目，请运行以下命令：
```
python3 ok --submit
```

您可以在 [Ok dashboard](http://ok.cs61a.org) 上查看您的提交。

对于我们要求您完成的函数，我们可能会提供一些初始代码。如果您不想使用这些代码，可以随意删除并从头开始。您也可以根据需要添加新的函数定义。

但是，请**不要**修改任何其他函数。这样做可能会导致您的代码无法通过我们的自动评分测试。另外，请不要更改任何函数签名（名称、参数顺序或参数数量）。

在整个项目中，您应该测试代码的正确性。经常测试是一个好习惯，这样可以轻松地找出任何问题。但是，您不应该测试*过于*频繁，以便给自己留出时间思考问题。

我们提供了一个名为 `ok` 的**自动评分器**，以帮助您测试代码并跟踪进度。第一次运行自动评分器时，系统会要求您**使用网络浏览器登录您的 Ok 帐户**。请照做。每次运行 `ok` 时，它都会在我们的服务器上备份您的工作和进度。

`ok` 的主要目的是测试您的实现。

我们建议您在**完成每个问题后**提交。只有您的最后一次提交会被评分。拥有更多代码备份对我们来说也很有用，以防您遇到提交问题。**如果您忘记提交，您的最后一次备份将自动转换为提交。**

如果您不希望我们记录您的工作备份或进度信息，可以运行：
```
python3 ok --local
```
使用此选项，任何信息都不会发送到我们的课程服务器。

如果您想交互式地测试您的代码，可以运行：
```
python3 ok -q [问题编号] -i
```
并插入相应的问题编号（例如 `01`）。这将运行该问题的测试，直到第一个失败的测试，然后让您有机会交互式地测试您编写的函数。

您还可以在 OK 中使用调试打印功能，方法是编写：
```
print("DEBUG:", x)
```
这将在您的终端中产生输出，而不会导致 OK 测试因额外输出而失败。

## 游戏玩法

一场“蚂蚁大战蜜蜂”的游戏包含一系列回合。在每个回合中，新的蜜蜂可能会进入蚁穴。然后，新的蚂蚁会被放置来保卫它们的蚁穴。最后，所有昆虫（先是蚂蚁，然后是蜜蜂）各自行动。蜜蜂要么试图向隧道末端移动，要么蜇伤挡路的蚂蚁。蚂蚁根据其类型执行不同的行动，例如收集更多食物或向蜜蜂投掷树叶。当一只蜜蜂到达隧道末端（你输了）、蜜蜂摧毁了存在的 `QueenAnt`（你输了），或者整个蜂群都被消灭了（你赢了）时，游戏结束。

<center>
  <img class="img-responsive center-block" src="img/gui_explanation.png" style="border: 1px solid #000;"/>
</center>

### 核心概念

**蚁巢 (The Colony)**：这是游戏进行的场所。蚁巢由若干个 `Place`（地点）连接而成，形成一个蜜蜂可以穿行的隧道。蚁巢还拥有一定数量的食物，可以消耗食物在隧道中放置蚂蚁。

**地点 (Places)**：一个地点连接到另一个地点形成隧道。玩家可以在每个地点放置一只蚂蚁。但是，一个地点可以有多只蜜蜂。

**蜂巢 (The Hive)**：这是蜜蜂的起源地。蜜蜂从蜂巢出来进入蚁巢。

**蚂蚁 (Ants)**：玩家通过从屏幕顶部的可用蚂蚁类型中选择来将蚂蚁放置在蚁巢中。每种类型的蚂蚁都有不同的行动，并且需要不同数量的蚁巢食物来放置。两种最基本的蚂蚁类型是 `HarvesterAnt`（收集蚁），它在每个回合为蚁巢增加一份食物；以及 `ThrowerAnt`（投掷蚁），它在每个回合向蜜蜂投掷一片叶子。您将实现更多种类的蚂蚁！

**蜜蜂 (Bees)**：在这个游戏中，蜜蜂是玩家必须保卫蚁巢免受其侵害的敌对力量。每个回合，蜜蜂要么前进到隧道中的下一个地点（如果没有蚂蚁挡路），要么蜇伤挡路的蚂蚁。当至少有一只蜜蜂到达隧道末端时，蜜蜂获胜。

### 核心类

上述概念各自对应一个类，封装了该概念的逻辑。以下是游戏中主要类的摘要：

*   **`GameState`**：代表蚁巢和一些关于游戏的状态信息，包括可用食物量、已用时间、`AntHomeBase` 的位置以及游戏中的所有 `Place`。
*   **`Place`**：代表一个容纳昆虫的单一地点。一个地点最多只能有一只 `Ant`，但可以有多只 `Bee`。`Place` 对象有一个左边的 `exit`（出口）和一个右边的 `entrance`（入口），它们也都是地点。蜜蜂通过移动到 `Place` 的 `exit` 来穿过隧道。
*   **`Hive`**：代表 `Bee` 开始的地方（在隧道的右侧）。
*   **`AntHomeBase`**：代表 `Ant` 正在保卫的地方（在隧道的左侧）。如果蜜蜂到达这里，它们就赢了 :(
*   **`Insect`**：`Ant` 和 `Bee` 的超类。所有昆虫都有 `health`（生命值）属性，表示其剩余生命值，以及一个 `place` 属性，表示它们当前所在的 `Place`。每个回合，游戏中所有活跃的 `Insect` 都会执行其 `action`（行动）。
*   **`Ant`**：代表蚂蚁。每个 `Ant` 子类都有特殊的属性或特殊的 `action`，使其与其他 `Ant` 类型区分开来。例如，`HarvesterAnt` 为蚁巢获取食物，而 `ThrowerAnt` 攻击 `Bee`。每种蚂蚁类型还有一个 `food_cost`（食物成本）属性，表示部署该类型蚂蚁一个单位所需的成本。
*   **`Bee`**：代表蜜蜂。每个回合，蜜蜂要么移动到其当前 `Place` 的 `exit`（如果该 `Place` 没有被蚂蚁 `blocked`（阻挡）），要么蜇伤占据同一 `Place` 的蚂蚁。

### 游戏布局

下面是 `GameState` 的可视化图。在您完成解锁测试和问题时，我们建议您绘制类似的图表以帮助理解。

<img class="img-responsive center-block" src="assets/colony-drawing.png" />

### 对象图

为了帮助您可视化所有类是如何协同工作的，我们还为您创建了一个对象图供您在工作时参考，您可以在[此处](diagram/ants_diagram.pdf)找到它：

<iframe id="antsdiagram" src="diagram/ants_diagram.pdf" width="100%" height="500px"></iframe>

### 开始游戏

游戏可以以两种模式运行：文本模式或图形用户界面 (GUI) 模式。无论哪种模式，游戏逻辑都是相同的，但 GUI 会强制执行回合时间限制，这使得游戏更刺激。文本界面主要用于调试和开发。

文件根据这两种模式进行了分离。`ants.py` 不涉及图形或回合时间限制。

要开始一个文本模式的游戏，请运行：
```
python3 ants_text.py
```

要开始一个图形界面的游戏，请运行：
```
python3 gui.py
```

当您启动图形版本时，应该会出现一个新的浏览器窗口。在初始实现中，您拥有无限的食物，并且您的蚂蚁只能向其当前 `Place` 中的蜜蜂投掷树叶。在您完成问题2之前，GUI 可能会崩溃，因为它还没有完全理解 `Place` 是什么！无论如何，请尝试玩一下游戏！您需要放置大量的 `ThrowerAnt`（第二种类型）才能阻止蜜蜂到达您的蚁后。

游戏有几个选项，您将在整个项目中使用它们，您可以使用 `python3 ants_text.py --help` 查看。
```
用法: ants_text.py [-h] [-d DIFFICULTY] [-w] [--food FOOD]

玩《蚂蚁大战蜜蜂》

可选参数:
  -h, --help            显示此帮助信息并退出
  -d DIFFICULTY         设置游戏难度 (test/easy/normal/hard/extra-hard)
  -w, --water           加载包含水域的完整布局
  --food FOOD           测试时开始的食物数量
```

## 入门视频

> **更新 (10/14)**：所有四个阶段的入门视频均已发布。

这些视频可能为完成项目中的编码问题提供一些有用的指导。

> 要观看这些视频，您应该登录您的 berkeley.edu 邮箱。

<iframe width="560" height="315" src="https://youtube.com/embed/watch?v=szmjnqjjxn4&list=PLx38hZJ5RLZcuFYxU1HlX9xmPGAFFAHOO" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p><a href='https://youtu.be/watch?v=szmjnqjjxn4&list=PLx38hZJ5RLZcuFYxU1HlX9xmPGAFFAHOO'>YouTube 链接</a></p>

## 第一阶段：基本游戏玩法

> **重要提交说明**：为了获得满分，
> 请在 **10月15日（星期五）** 前提交完成第一阶段的内容（占1分）。

在第一阶段，您将完成允许使用两种基本 `Ant`（蚂蚁）进行基本游戏玩法的实现：`HarvesterAnt`（收集蚁）和 `ThrowerAnt`（投掷蚁）。

### 问题 0 (0 分)

在您阅读了*整个* `ants.py` 文件后，与您的搭档一起回答以下问题。

要提交您的答案，请运行：
```
python3 ok -q 00 -u
```

如果您在回答这些问题时遇到困难，可以尝试再次通读 `ants.py`，查阅上面的[核心概念](#核心概念)/[核心类](#核心类)部分，或在 Piazza 的问题0主题帖中提问。

1.  昆虫的 `health` 属性有什么意义？这个值会改变吗？如果会，是如何改变的？
2.  以下哪项是 `Insect` 类的类属性？
3.  `Ant` 类的 `health` 属性是实例属性还是类属性？为什么？
4.  `Ant` 子类（例如 `ThrowerAnt`）的 `damage` 属性是实例属性还是类属性？为什么？
5.  `Ant` 和 `Bee` 都继承自哪个类？
6.  `Ant` 的实例和 `Bee` 的实例有什么共同点？
7.  在任何给定时间（在问题8之前），一个 `Place` 中最多可以有多少只昆虫？
8.  一只 `Bee` 在它的一个回合中会做什么？
9.  游戏什么时候会输掉？

记住运行：
```
python3 ok -q 00 -u
```

### 问题 1 (1 分)

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q 01 -u
```

**A部分**：目前，放置任何类型的 `Ant` 都没有成本，因此游戏没有挑战性。基类 `Ant` 的 `food_cost` 为零。根据下表中的“食物成本”列，覆盖 `HarvesterAnt` 和 `ThrowerAnt` 的此类别属性。

<table class="ant">
  <tr>
    <td><b>类</b></td>
    <td><b>食物成本</b></td>
    <td><b>初始生命值</b></td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_harvester.gif" /> <br> <code>HarvesterAnt</code></td>
    <td>2</td>
    <td>1</td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_thrower.gif" /> <br> <code>ThrowerAnt</code></td>
    <td>3</td>
    <td>1</td>
  </td>
</table>

**B部分**：既然放置一个 `Ant` 需要消耗食物，我们就需要能够收集更多的食物！为了解决这个问题，实现 `HarvesterAnt` 类。`HarvesterAnt` 是一种 `Ant`，它的 `action` 是将一份食物添加到 `gamestate.food` 总量中。

编写代码后，测试您的实现：
```
python3 ok -q 01
```

尝试通过运行 `python3 gui.py` 来玩游戏。一旦您放置了一个 `HarvesterAnt`，您应该在每个回合积累食物。您也可以放置 `ThrowerAnt`，但您会发现它们只能攻击与其在同一个 `Place` 的蜜蜂，这使得获胜有点困难。

### 问题 2 (1 分)

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q 02 -u
```

在这个问题中，您将通过添加跟踪入口的代码来完成 `Place.__init__`。目前，一个 `Place` 只跟踪它的 `exit`。我们希望一个 `Place` 也能跟踪它的入口。一个 `Place` 只需要跟踪一个 `entrance`。跟踪入口对于一个 `Ant` 需要查看隧道中它前面有哪些 `Bee` 时会很有用。

然而，简单地将入口传递给 `Place` 构造函数会有问题；我们需要在创建 `Place` 之前同时拥有出口和入口！（这是一个[先有鸡还是先有蛋](https://en.wikipedia.org/wiki/Chicken_or_the_egg)的问题。）为了解决这个问题，我们将改为以下方式跟踪入口。`Place.__init__` 应使用此逻辑：

*   一个新创建的 `Place` 总是以其 `entrance` 为 `None` 开始。
*   如果该 `Place` 有一个 `exit`，则该 `exit` 的 `entrance` 设置为该 `Place`。

> *提示：* 请记住，当调用 `__init__` 方法时，第一个参数 `self` 会绑定到新创建的对象。

> *提示：* 如果事情变得混乱，尝试画出两个相邻的 `Place`。在 GUI 中，一个地点的 `entrance` 在其右侧，而 `exit` 在其左侧。

> *提示：* 请记住，`Place` 并非存储在列表中，因此您无法通过索引访问它们。这意味着您**不能**执行类似 `colony[index + 1]` 的操作来访问相邻的 `Place`。那么，您如何从一个地点移动到另一个地点呢？

<img class="img-responsive center-block" src="assets/colony-drawing.png" />

编写代码后，测试您的实现：
```
python3 ok -q 02
```

### 问题 3 (1 分)

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q 03 -u
```

为了让 `ThrowerAnt` 投掷叶子，它必须知道要击中哪只蜜蜂。`ThrowerAnt` 类中提供的 `nearest_bee` 方法的实现只允许它们击中同一 `Place` 中的蜜蜂。您的任务是修复它，以便 `ThrowerAnt` 将 `throw_at` **不在 `Hive` 中的**最近的蜜蜂。这包括与 `ThrowerAnt` 在同一 `Place` 中的蜜蜂。

> *提示：* 所有 `Place` 都有一个 `is_hive` 属性，当该地点是 `Hive` 时，该属性为 `True`。

更改 `nearest_bee`，使其从包含蜜蜂的最近地点返回一只随机的 `Bee`。您的实现应遵循以下逻辑：

*   从 `ThrowerAnt` 的当前 `Place` 开始。
*   对于每个地点，如果其中有任何蜜蜂，则返回一只随机蜜蜂；如果没有，则检查其前面的地点（存储为当前地点的 `entrance`）。
*   如果没有可攻击的蜜蜂，则返回 `None`。

> *提示*：`ants.py` 中提供的 `random_bee` 函数会从蜜蜂列表中返回一只随机蜜蜂，如果列表为空则返回 `None`。

> *提示*：提醒一下，如果一个 `Place` 中没有蜜蜂，那么该 `Place` 实例的 `bees` 属性将是一个空列表。

> *提示*：在可视化测试用例时遇到困难？尝试在纸上画出来！[游戏布局](#game-layout)中提供的示例图显示了此问题的第一个测试用例。

编写代码后，测试您的实现：
```
python3 ok -q 03
```

实现 `nearest_bee` 后，`ThrowerAnt` 应该能够 `throw_at` 前方不在 `Hive` 中的 `Bee`。确保您的蚂蚁行为正确！要开始一个有十个食物的游戏（以便于测试）：
```
python3 gui.py --food 10
```

请确保在检查点截止日期前使用以下命令提交：
```
python3 ok --submit
```

您可以通过运行以下命令来检查是否已完成第一阶段的问题：
```
python3 ok --score
```

恭喜！您已完成本项目的第一阶段！

## 第二阶段：蚂蚁！

> **重要提交说明**：为了获得满分，
>
> *   请在 **10月19日（星期二）** 前提交完成第二阶段和第三阶段的内容（占1分）。

既然您已经用两种类型的 `Ant` 实现了基本的游戏玩法，让我们为蚂蚁攻击蜜蜂的方式增添一些特色。在这个阶段，您将实现几种具有不同攻击策略的 `Ant`。

在本节中实现每个 `Ant` 子类后，您需要将其 `implemented` 类属性设置为 `True`，这样该类型的蚂蚁才会出现在 GUI 中。随时尝试使用每种新蚂蚁进行游戏以测试其功能！

对于您的第二阶段蚂蚁，尝试 `python3 gui.py -d easy` 来对抗多隧道布局中的完整蜂群，如果您想要真正的挑战，可以尝试 `-d normal`、`-d hard` 或 `-d extra-hard`！如果蜜蜂数量太多而无法消灭，您可能需要创建一些新的蚂蚁。

### 问题 4 (2 分)

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q 04 -u
```

`ThrowerAnt` 对蜜蜂构成了强大的威胁，但其食物成本很高。在这个问题中，您将实现 `ThrowerAnt` 的两个子类，它们成本较低，但投掷距离受到限制：

*   `LongThrower` 只能 `throw_at` 至少经过 5 次 `entrance` 过渡后找到的 `Bee`。它无法击中与其在同一 `Place` 或其前方 4 个 `Place` 内的 `Bee`。如果存在两只 `Bee`，一只离 `LongThrower` 太近，另一只在其射程内，则 `LongThrower` 应仅投掷较远的 `Bee`（在其射程内），而不是试图击中较近的 `Bee`。
*   `ShortThrower` 只能 `throw_at` 最多经过 3 次 `entrance` 过渡后找到的 `Bee`。它无法投掷超过其前方 3 个 `Place` 的任何蜜蜂。

这两种特化投掷蚁都不能 `throw_at` 恰好在 4 个 `Place` 之外的 `Bee`。

<table class="ant">
  <tr>
    <td><b>类</b></td>
    <td><b>食物成本</b></td>
    <td><b>初始生命值</b></td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_shortthrower.gif" /> <br>
      <code>ShortThrower</code></td>
    <td>2</td>
    <td>1</td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_longthrower.gif" /> <br> <code>LongThrower</code></td>
    <td>2</td>
    <td>1</td>
  </tr>
</table>

要实现这些新的投掷蚂蚁，您的 `ShortThrower` 和 `LongThrower` 类应从基类 `ThrowerAnt` 继承 `nearest_bee` 方法。选择投掷蚂蚁攻击哪只蜜蜂的逻辑是相同的，只是 `ShortThrower` 和 `LongThrower` 蚂蚁分别具有最大和最小射程。

为此，请修改 `nearest_bee` 方法以引用 `min_range` 和 `max_range` 属性，并且仅当蜜蜂在射程内时才返回蜜蜂。

确保在 `ThrowerAnt` 类中为这些 `min_range` 和 `max_range` 属性赋予适当的值，以使 `ThrowerAnt` 的行为保持不变。然后，使用适当约束的射程实现子类 `LongThrower` 和 `ShortThrower`。

您**不应**需要在 `ThrowerAnt`、`ShortThrower` 和 `LongThrower` 之间重复任何代码。

> *提示：* `float('inf')` 返回一个表示为浮点数的无限正值，可以与其他数字进行比较。

> *提示：* 您可以在 Python 中链接不等式：例如 `2 < x < 6` 将检查 `x` 是否介于 2 和 6 之间。此外，`min_range` 和 `max_range` 应标记一个包含性范围。

> **重要提示：**
> 确保您的类属性名为 `max_range` 和 `min_range`。
> 测试直接引用这些属性名称，如果您使用其他名称，将会出错。

不要忘记将 `LongThrower` 和 `ShortThrower` 的 `implemented` 类属性设置为 `True`。

编写代码后，测试您的实现（重新运行03的测试以确保它们仍然有效）：
```
python3 ok -q 03
python3 ok -q 04
```

👩🏽‍💻👨🏿‍💻 [结对编程？](../../articles/pair-programming)
记住轮流担任驾驶员和导航员的角色。
驾驶员控制键盘；
导航员观察、提问并提出想法。

### 问题 5 (3 分)

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q 05 -u
```

实现 `FireAnt`（火焰蚁），它在受到伤害时会造成伤害。具体来说，如果它受到 `amount` 点生命值的伤害，它会对同一地点内的所有蜜蜂造成 `amount` 点伤害（这称为*反射伤害*）。如果它死亡，它会造成额外的伤害，伤害量由其 `damage` 属性指定，该属性在 `FireAnt` 类中定义为默认值 `3`。

要实现这一点，请覆盖 `FireAnt` 的 `reduce_health` 方法。您覆盖的方法应调用从超类 (`Ant`) 继承的 `reduce_health` 方法，以减少当前 `FireAnt` 实例的生命值。在 `FireAnt` 实例上调用*继承的* `reduce_health` 方法会使昆虫的 `health` 减少给定的 `amount`，并在其 `health` 降至零或更低时将其从其位置移除。

> *提示：*
> **不要**调用 `self.reduce_health`，
> 否则您会陷入递归循环。（您能看出原因吗？）

然而，您的方法还需要包含反射伤害逻辑：

*   确定反射伤害量：
    从对蚂蚁造成的 `amount` 开始，
    然后如果蚂蚁的生命值降至0，则添加 `damage`。
*   对于地点中的每只蜜蜂，通过调用每只蜜蜂相应的 `reduce_health` 方法，用总伤害量对其造成伤害。

> **重要提示：**
> `FireAnt` 必须在从其 `place` 中移除*之前*造成伤害，
> 因此请仔细注意 `reduce_health` 中逻辑的顺序。

<table class="ant">
  <tr>
    <td><b>类</b></td>
    <td><b>食物成本</b></td>
    <td><b>初始生命值</b></td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_fire.gif" /> <br> <code>FireAnt</code></td>
    <td>5</td>
    <td>3</td>
  </td>
</table>

> *提示：* 伤害一只蜜蜂可能会导致它从其位置被移除。如果您迭代一个列表，但同时更改该列表的内容，您[可能无法访问所有元素](https://docs.python.org/3/tutorial/controlflow.html#for-statements)。这可以通过创建列表的副本 > 来防止。您可以使用列表切片，或使用内置的 `list` 函数。
> ```python
>  >>> lst = [1,2,3,4]
>  >>> lst[:]
> [1, 2, 3, 4]
>  >>> list(lst)
> [1, 2, 3, 4]
>  >>> lst[:] is not lst and list(lst) is not lst
> True
> ```

完成 `FireAnt` 的实现后，给它一个值为 `True` 的类属性 `implemented`。

> *注意：*
> 即使您正在覆盖超类的 `reduce_health` 函数
> (`Ant.reduce_health`)，
> 您仍然可以通过调用它在您的实现中使用此方法。
> 注意这不是递归。（为什么不是？）

编写代码后，测试您的实现：
```
python3 ok -q 05
```

您还可以通过玩一两局游戏来测试您的程序！`FireAnt` 在被蜇伤时应该摧毁所有同在一处的蜜蜂。要开始一个有十个食物的游戏（以便于测试）：
```
python3 gui.py --food 10
```

## 第三阶段：更多蚂蚁！

> **重要提交说明**：为了获得满分，
>
> *   请在 **10月19日（星期二）** 前提交完成第二阶段和第三阶段的内容。

### 问题 6 (1 分)

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q 06 -u
```

我们将通过实现 `WallAnt`（墙壁蚁）来为我们光荣的基地增加一些保护，这是一种每回合什么都不做的蚂蚁。`WallAnt` 之所以有用，是因为它具有很高的 `health`（生命值）。

<table class="ant">
  <tr>
    <td><b>类</b></td>
    <td><b>食物成本</b></td>
    <td><b>初始生命值</b></td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_wall.gif" /> <br> <code>WallAnt</code></td>
    <td>4</td>
    <td>4</td>
  </td>
</table>

与之前的蚂蚁不同，我们没有为您提供类头。请从头开始实现 `WallAnt` 类。为其赋予一个值为 `'Wall'` 的类属性 `name`（以便图形正常工作）和一个值为 `True` 的类属性 `implemented`（以便您可以在游戏中使用它）。

> *提示*：首先，看看之前问题的蚂蚁是如何实现的！

编写代码后，测试您的实现：
```
python3 ok -q 06
```

### 问题 7 (3 分)

实现 `HungryAnt`（饥饿蚁），它会从其 `place`（位置）中选择一只随机的 `Bee`（蜜蜂）并将其整个吃掉。吃掉一只 `Bee` 后，`HungryAnt` 必须花3个回合咀嚼才能再次进食。如果没有可吃的蜜蜂，`HungryAnt` 将什么也不做。

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q 07 -u
```

我们没有为您提供类头。请从头开始实现 `HungryAnt` 类。为其赋予一个值为 `'Hungry'` 的类属性 `name`（以便图形正常工作）和一个值为 `True` 的类属性 `implemented`（以便您可以在游戏中使用它）。

> *提示：*
> 当一只 `Bee` 被吃掉时，它应该失去所有生命值。
> 我们是否可以调用一个已有的函数作用于 `Bee`，使其生命值降至0？

<table class="ant">
  <tr>
    <td><b>类</b></td>
    <td><b>食物成本</b></td>
    <td><b>初始生命值</b></td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_hungry.gif" /> <br> <code>HungryAnt</code></td>
    <td>4</td>
    <td>1</td>
  </td>
</table>

为 `HungryAnt` 提供一个 `chew_duration` **类**属性，用于存储 `HungryAnt` 咀嚼所需的回合数（设置为3）。此外，为每个 `HungryAnt` 提供一个**实例**属性 `chew_countdown`，用于计算其剩余咀嚼回合数（初始化为0，因为在开始时它还没有吃任何东西。您也可以将 `chew_countdown` 视为 `HungryAnt` 可以吃另一只 `Bee` 之前的回合数）。

实现 `HungryAnt` 的 `action` 方法：首先，检查它是否正在咀嚼；如果是，则减少其 `chew_countdown`。否则，通过将其 `place` 中的一只随机 `Bee` 的生命值降至0来吃掉它。确保在吃掉一只蜜蜂时设置 `chew_countdown`！

> *提示*：除了 `action` 方法，确保您也实现了 `__init__` 方法，以便 `HungryAnt` 以适当的 `health` 开始！

编写代码后，测试您的实现：
```
python3 ok -q 07
```

我们现在有一些强大的进攻部队来帮助消灭蜜蜂，但让我们确保我们的防御工作也跟得上。在这个阶段，您将实现具有特殊防御能力的蚂蚁，例如增加生命值和保护其他蚂蚁的能力。

👩🏽‍💻👨🏿‍💻 [结对编程？](../../articles/pair-programming)
现在是交换角色的好时机。
交换角色可以确保
你们都能从担任每个角色的学习经验中受益。

### 问题 8 (3 分)

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q 08 -u
```

目前，我们的蚂蚁非常脆弱。我们希望提供一种方法来帮助它们在蜜蜂的猛攻下持续更长时间。于是 `BodyguardAnt`（保镖蚁）登场了。

<table class="ant">
  <tr>
    <td><b>类</b></td>
    <td><b>食物成本</b></td>
    <td><b>初始生命值</b></td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_bodyguard.gif" /> <br> <code>BodyguardAnt</code></td>
    <td>4</td>
    <td>2</td>
  </tr>
</table>

`BodyguardAnt` 与普通蚂蚁不同，因为它是一个 `ContainerAnt`（容器蚁）；它可以容纳并保护另一只蚂蚁，所有这些都在同一个 `Place`（地点）中。当一只 `Bee`（蜜蜂）蜇伤一只蚂蚁所在的 `Place`（该地点中一只蚂蚁容纳着另一只蚂蚁）时，只有容器蚂蚁会受到伤害。容器内的蚂蚁仍然可以执行其原始行动。如果容器蚂蚁死亡，被容纳的蚂蚁仍然留在该地点（然后可能会受到伤害）。

每个 `ContainerAnt` 都有一个实例属性 `ant_contained`，用于存储它所容纳的蚂蚁。这个蚂蚁 `ant_contained` 最初为 `None`，表示尚未存储任何蚂蚁。实现 `store_ant` 方法，使其将 `ContainerAnt` 的 `ant_contained` 实例属性设置为传入的 `ant` 参数。同时实现 `ContainerAnt` 的 `action` 方法，以便在其当前容纳蚂蚁时执行其 `ant_contained` 的行动。

此外，您需要在整个程序中进行以下修改，以便容器蚂蚁及其容纳的蚂蚁可以同时占据一个地点（每个地点最多两只蚂蚁），但前提是其中只有一只是容器蚂蚁：

1.  `Ant` 类有一个 `can_contain` 方法，但它总是返回 `False`。覆盖 `ContainerAnt.can_contain` 方法，使其接受一个蚂蚁 `other` 作为参数，并在以下情况下返回 `True`：
    *   此 `ContainerAnt` 尚未容纳其他蚂蚁。
    *   另一只蚂蚁不是容器蚂蚁。
2.  修改 `Ant.add_to` 以允许容器蚂蚁和非容器蚂蚁根据以下规则占据同一地点：
    *   如果最初占据一个地点的蚂蚁可以容纳正在添加的蚂蚁，则两只蚂蚁都占据该地点，并且原始蚂蚁容纳正在添加的蚂蚁。
    *   如果正在添加的蚂蚁可以容纳最初在该空间中的蚂蚁，则两只蚂蚁都占据该地点，并且正在添加的（容器）蚂蚁容纳原始蚂蚁。
    *   如果两只 `Ant` 都不能容纳另一只，则引发与之前相同的 `AssertionError`（即起始代码中已存在的那个）。
    *   **重要提示：** 如果特定 `Place` 中有两只蚂蚁，则 `Place` 实例的 `ant` 属性应指向容器蚂蚁，并且容器蚂蚁应容纳非容器蚂蚁。
3.  添加一个 `BodyguardAnt.__init__`，用于设置蚂蚁的初始生命值。

> *提示*：
> 您可能会发现每个 `Ant` 都有的 `is_container` 属性对于检查特定 `Ant` 是否为容器很有用。
> 您还应该利用您编写的 `can_contain` 方法，避免重复代码。

> `ContainerAnt.__init__` 的构造函数实现如下：
> ```python
>  def __init__(self, *args, **kwargs):
>      super().__init__(*args, **kwargs)
>      self.ant_contained = None
> ```
> 正如我们在 Hog 项目中看到的，`args` 绑定到所有位置参数（即所有不带关键字传递的参数），而 `kwargs` 绑定到所有关键字参数。
> 这确保了两组参数都传递给 Ant 构造函数。
>
> 实际上，这意味着构造函数与其父类的构造函数 (`Ant.__init__`) 完全相同，
> 但在这里我们还设置了 `self.ant_contained = None`。

完成 `BodyguardAnt` 的实现后，为其赋予一个值为 `True` 的类属性 `implemented`。

编写代码后，测试您的实现：
```
python3 ok -q 08
```

### 问题 9 (1 分)

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q 09 -u
```

`BodyguardAnt` 提供了强大的防御能力，但俗话说，最好的防御是进攻。`TankAnt`（坦克蚁）是一个容器，它保护其所在位置的蚂蚁，并且每回合对其所在位置的所有蜜蜂造成1点伤害。

<table class="ant">
  <tr>
    <td><b>类</b></td>
    <td><b>食物成本</b></td>
    <td><b>初始生命值</b></td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_tank.gif" /> <br> <code>TankAnt</code></td>
    <td>6</td>
    <td>2</td>
  </tr>
</table>

我们没有为您提供类头。请从头开始实现 `TankAnt` 类。为其赋予一个值为 `'Tank'` 的类属性 `name`（以便图形正常工作）和一个值为 `True` 的类属性 `implemented`（以便您可以在游戏中使用它）。

您不应需要修改 `TankAnt` 类之外的任何代码。如果您发现需要在其他地方进行更改，请寻找一种编写上一个问题的代码的方式，使其不仅适用于 `BodyguardAnt` 和 `TankAnt` 对象，而且适用于一般的容器蚂蚁。

> *提示*：您唯一需要从 `TankAnt` 的父类中覆盖的方法是 `__init__` 和 `action`。

> *提示*：与 `FireAnt` 类似，伤害一只蜜蜂可能会导致它从其位置被移除。

编写代码后，测试您的实现：
```
python3 ok -q 09
```

## 第四阶段：水与力量

> **重要提交说明**：为了获得满分，
>
> *   请在 **10月22日（星期五）** 前提交完成所有阶段的内容。
>
> 您可以通过在 **10月21日（星期四）** 前提交整个项目来获得一个额外的加分点。

在最后阶段，您将通过引入一种新型地点和能够占据该地点的新蚂蚁，为游戏增添最后的精彩。其中一只蚂蚁是所有蚂蚁中最重要的一只：蚁后！

### 问题 10 (1 分)

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q 10 -u
```

让我们在蚁巢中加入水！目前只有两种类型的地点，即 `Hive`（蜂巢）和普通的 `Place`（地点）。为了让事情更有趣，我们将创建一种名为 `Water`（水域）的新型 `Place`。

只有防水的昆虫才能被放置在 `Water` 中。为了确定一个 `Insect`（昆虫）是否防水，向 `Insect` 类添加一个新的名为 `is_waterproof` 的类属性，并将其设置为 `False`。由于蜜蜂会飞，将其 `is_waterproof` 属性设置为 `True`，覆盖继承的值。

现在，为 `Water` 实现 `add_insect` 方法。首先，无论昆虫是否防水，都将其添加到该地点。然后，如果昆虫不防水，则将其生命值降至0。*不要重复程序中其他地方的代码。* 相反，使用已经定义的方法。

编写代码后，测试您的实现：
```
python3 ok -q 10
```

完成此问题后，玩一个包含水域的游戏。要访问包含水域的 `wet_layout`，请在开始游戏时添加 `--water` 选项（或简写为 `-w`）。
```
python3 gui.py --water
```

👩🏽‍💻👨🏿‍💻 [结对编程？](../../articles/pair-programming)
记住轮流担任驾驶员和导航员的角色。
驾驶员控制键盘；
导航员观察、提问并提出想法。

### 问题 11 (1 分)

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q 11 -u
```

目前还没有可以放置在 `Water` 上的蚂蚁。实现 `ScubaThrower`（潜水投掷蚁），它是 `ThrowerAnt`（投掷蚁）的一个子类，成本更高且防水，*但其他方面与其基类相同*。`ScubaThrower` 在放置在 `Water` 中时不应损失生命值。

<table class="ant">
  <tr>
    <td><b>类</b></td>
    <td><b>食物成本</b></td>
    <td><b>初始生命值</b></td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_scuba.gif" /> <br> <code>ScubaThrower</code></td>
    <td>6</td>
    <td>1</td>
  </tr>
</table>

我们没有为您提供类头。请从头开始实现 `ScubaThrower` 类。为其赋予一个值为 `'Scuba'` 的类属性 `name`（以便图形正常工作），并记住将类属性 `implemented` 设置为 `True`（以便您可以在游戏中使用它）。

编写代码后，测试您的实现：
```
python3 ok -q 11
```

### 问题 12 (3 分)

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q 12 -u
```

最后，实现 `QueenAnt`（蚁后）。蚁后是一种防水的 `ScubaThrower`（潜水投掷蚁），它通过其勇敢激励着她的同伴蚂蚁。除了标准的 `ScubaThrower` 行动外，`QueenAnt` 在每次执行行动时都会使其身后所有蚂蚁的伤害加倍。一旦一只蚂蚁的伤害被加倍，在随后的回合中不会再次加倍。

> 注意：`FireAnt`（火焰蚁）的反射伤害不应加倍，只有当其生命值降至0时造成的额外伤害才应加倍。

> 注意：如果您较早下载了项目，有一些解锁问题已不再适用。我们不会要求您重新下载项目，而是会为您提供受影响问题的答案：
>
> *哪个 QueenAnt 实例是真正的 QueenAnt？*
>
> 第一个被实例化的 QueenAnt
>
> *在第一个 QueenAnt 实例化之后实例化的任何 QueenAnt 实例会发生什么？*
>
> 其生命值在执行第一个行动时降至0

<table class="ant">
  <tr>
    <td><b>类</b></td>
    <td><b>食物成本</b></td>
    <td><b>初始生命值</b></td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_queen.gif" /> <br> <code>QueenAnt</code></td>
    <td>7</td>
    <td>1</td>
  </tr>
</table>

然而，权力越大，责任越大。`QueenAnt` 受三条特殊规则的约束：

1.  如果蚁后的生命值降至0，则蚂蚁方失败。您需要在 `QueenAnt` 中覆盖 `Ant.reduce_health`，并在这种情况下调用 `ants_lose()`，以向模拟器发出游戏结束的信号。（如果任何蜜蜂到达隧道末端，蚂蚁方仍然会失败。）
2.  只能有一只蚁后。不能构建第二只蚁后。要检查是否可以构建一只蚂蚁，我们使用 `Ant.construct()` 类方法来在可能的情况下构建一只蚂蚁，如果不可能则返回 `None`。您需要将 `Ant.construct` 作为 `QueenAnt` 的类方法进行覆盖，以添加此检查。要跟踪是否已经创建了蚁后，您可以使用添加到当前 `GameState` 的实例变量。
3.  蚁后不能被移除。尝试移除蚁后应无效（但不应导致错误）。您需要在 `QueenAnt` 中覆盖 `Ant.remove_from` 来强制执行此条件。

> *提示：*
> 思考如何调用 `QueenAnt` 超类的 `construct` 方法。
> 请记住，您最终想要构建的是 `QueenAnt`，而不是普通的 `Ant` 或 `ScubaThrower`。

> *提示：*
> 您可以通过从蚂蚁的 `place.exit` 开始，然后重复跟随其 `exit` 来找到 `QueenAnt` 后面隧道中的每个 `Place`。
> 隧道末端 `Place` 的 `exit` 是 `None`。

> *提示：*
> 为了避免将蚂蚁的伤害加倍两次，
> 以某种方式标记已增强的蚂蚁，
> 这种方式在 `QueenAnt.action` 的多次调用之间保持不变。

> *提示：*
> 在增强蚂蚁的伤害时，
> 请记住一个 `Place` 中可以有多于一只蚂蚁，
> 例如一只蚂蚁正在保护另一只蚂蚁。

编写代码后，测试您的实现：
```
python3 ok -q 12
```

### 额外加分 (2 分)

> 在 Office Hours 和 Project Parties 期间，工作人员将优先帮助学生解决必做问题。除非[队列](https://oh.cs61a.org/)为空，否则我们不会为此问题提供帮助。

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q EC -u
```

实现最后两种投掷蚁，它们不造成伤害，而是在它们 `throw_at`（投掷）的 `Bee`（蜜蜂）实例的 `action`（行动）方法上施加一个临时的“状态”。这个“状态”会持续一定的回合数，之后便不再生效。

我们将实现两个继承自 `ThrowerAnt` 的新蚂蚁。

*   `SlowThrower`（减速投掷蚁）向蜜蜂投掷粘性糖浆，使其减速3回合。当蜜蜂被减速时，它只能在 `gamestate.time` 为偶数的回合移动，否则什么也做不了。如果一只蜜蜂在已经被减速的情况下再次被糖浆击中，它将被额外减速3回合。
*   `ScaryThrower`（惊吓投掷蚁）恐吓附近的蜜蜂，使其后退而不是前进。（如果蜜蜂已经在蜂巢旁边并且无法再后退，它不应移动。要检查蜜蜂是否在蜂巢旁边，您可能会发现 `Place` 的 `is_hive` 实例属性很有用）。蜜蜂会一直保持惊吓状态，直到它们尝试后退两次。如果蜜蜂被减速且 `gamestate.time` 为奇数，则它们无法尝试后退。*一旦一只蜜蜂被惊吓过一次，它就再也不会被惊吓了。*

<table class="ant">
  <tr>
    <td><b>类</b></td>
    <td><b>食物成本</b></td>
    <td><b>初始生命值</b></td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_slow.gif" /> <br> <code>SlowThrower</code></td>
    <td>4</td>
    <td>1</td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_scary.gif" /> <br> <code>ScaryThrower</code></td>
    <td>6</td>
    <td>1</td>
  </tr>
</table>

为了完成这两种蚂蚁的实现，您需要适当地设置它们的类属性，并在 `Bee` 上实现 `slow` 和 `scare` 方法，这些方法会在特定的蜜蜂上施加各自的状态。您可能还需要编辑 `Bee` 的其他一些方法。

您可以运行一些提供的测试，但它们并不详尽：
```
python3 ok -q EC
```

确保测试您的代码！您的代码应该能够对目标施加多种状态；每个新状态都适用于蜜蜂当前（可能先前已受影响）的行动方法。

## 可选问题

### 可选问题 1

> 在 Office Hours 和 Project Parties 期间，工作人员将优先帮助学生解决必做问题。除非[队列](https://oh.cs61a.org/)为空，否则我们不会为此问题提供帮助。

在编写任何代码之前，请阅读说明并测试您对问题的理解：
```
python3 ok -q optional1 -u
```

实现 `NinjaAnt`（忍者蚁），它可以伤害所有路过的 `Bee`（蜜蜂），但永远不会被蜇伤。

<table class="ant">
  <tr>
    <td><b>类</b></td>
    <td><b>食物成本</b></td>
    <td><b>初始生命值</b></td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_ninja.gif" /> <br> <code>NinjaAnt</code></td>
    <td>5</td>
    <td>1</td>
  </td>
</table>

`NinjaAnt` 不会阻挡飞过的 `Bee` 的路径。要实现此行为，首先修改 `Ant` 类以包含一个新的名为 `blocks_path` 的类属性，并将其设置为 `True`，然后在 `NinjaAnt` 类中将 `blocks_path` 的值覆盖为 `False`。

其次，修改 `Bee` 的 `blocked` 方法，使其在以下情况下返回 `False`：`Bee` 的 `place` 中没有 `Ant`，或者有 `Ant` 但其 `blocks_path` 属性为 `False`。现在 `Bee` 会直接飞过 `NinjaAnt`。

最后，我们希望 `NinjaAnt` 能够伤害所有飞过的 `Bee`。在 `NinjaAnt` 中实现 `action` 方法，使其通过其 `damage` 属性减少与 `NinjaAnt` 在同一 `place` 的所有 `Bee` 的生命值。与 `FireAnt` 类似，您必须迭代一个可能正在变化的蜜蜂列表。

> *提示*：在可视化测试用例时遇到困难？尝试在纸上画出来！有关帮助，请参阅[游戏布局](#game-layout)中的示例。

编写代码后，测试您的实现：
```
python3 ok -q optional1
```

挑战一下，尝试仅使用 `HarvesterAnt` 和 `NinjaAnt` 赢得游戏。

### 可选问题 2

> 在 Office Hours 和 Project Parties 期间，工作人员将优先帮助学生解决必做问题。除非[队列](https://oh.cs61a.org/)为空，否则我们不会为此问题提供帮助。

我们秘密开发这只蚂蚁已经很久了。它非常危险，以至于我们不得不将它锁在超级隐蔽的 CS61A 地下金库中，但我们最终认为它已经准备好投入战场了。在这个问题中，您将实现最后一种蚂蚁——`LaserAnt`（激光蚁），一种带有特殊功能的 `ThrowerAnt`（投掷蚁）。

> *注意：*
> 此问题没有解锁测试。

<table class="ant">
  <tr>
    <td><b>类</b></td>
    <td><b>食物成本</b></td>
    <td><b>初始生命值</b></td>
  </tr>
  <tr>
    <td><img class="img-responsive center-block" src="assets/insects/ant_laser.gif" /> <br> <code>LaserAnt</code></td>
    <td>10</td>
    <td>1</td>
  </tr>
</table>

`LaserAnt` 发射强大的激光，伤害路径上所有敢于阻挡的生物。所有类型的 `Bee` 和 `Ant` 都有被 `LaserAnt` 伤害的风险。当 `LaserAnt` 行动时，它会伤害其所在位置（不包括自身，但包括其容器，如果它有的话）以及其前方位置的所有 `Insect`，不包括 `Hive`。

如果仅此而已，`LaserAnt` 对我们来说就太强大了，无法控制。`LaserAnt` 的基础伤害为 `2`。但是，`LaserAnt` 的激光有一些怪癖。激光每远离 `LaserAnt` 的位置一个单位，其威力就会减弱 `0.25`。此外，`LaserAnt` 的电池有限。`LaserAnt` 每次实际伤害一个 `Insect`，其激光的总伤害就会降低 `0.0625` (1/16)。如果由于这些限制，`LaserAnt` 的伤害变为负数，则它只会造成0点伤害。

> 回合内具体事物的伤害顺序未指定。

为了完成这只终极蚂蚁的实现，请通读 `LaserAnt` 类，适当地设置类属性，并实现以下两个函数：

1.  `insects_in_front` 是一个实例方法，由 `action` 方法调用，它返回一个字典，其中每个键是一个 `Insect`，每个对应的值是该 `Insect` 与 `LaserAnt` 相距的距离（以地点为单位）。该字典应包括与 `LaserAnt` 在同一地点或在其前方的所有 `Insect`，不包括 `LaserAnt` 本身。
2.  `calculate_damage` 是一个实例方法，它接受 `distance`（昆虫与 `LaserAnt` 实例的距离）作为参数。它根据以下因素返回 `LaserAnt` 实例应造成的伤害：
    1.  一个 `Insect` 与 `LaserAnt` 实例的距离 `distance`。
    2.  这个 `LaserAnt` 已经伤害过的 `Insect` 数量，存储在 `insects_shot` 实例属性中。

除了实现上述方法外，您可能还需要根据需要在 `LaserAnt` 类中修改、添加或使用类或实例属性。

您可以运行提供的测试，但它并不详尽：
```
python3 ok -q optional2
```

确保测试您的代码！

## 项目提交

此时，运行整个自动评分器，看看是否有任何测试未通过：
```
python3 ok
```

您还可以检查您在项目各个部分的得分，包括附加题：
```
python3 ok --score
```

满意后，提交以完成项目。
```
python3 ok --submit
```

**如果您有搭档，请确保在 [okpy](https://okpy.org/) 上的项目提交中添加他们。**

**您现在已经完成了这个项目！** 如果您还没有尝试过，您应该玩一下这个游戏！
```
python3 gui.py [-h] [-d DIFFICULTY] [-w] [--food FOOD]
```

**致谢：** Tom Magrino 和 Eric Tzeng 与 John DeNero 共同开发了这个项目。Jessica Wan 贡献了最初的美术设计。Joy Jeng 和 Mark Miyashita 发明了蚁后。许多其他人也为这个项目做出了贡献！

新的概念艺术由 Alana Tran、Andrew Huang、Emilee Chen、Jessie Salas、Jingyi Li、Katherine Xu、Meena Vempaty、Michelle Chang 和 Ryan Davis 绘制。
